<template lang="pug">
  #avatar.transition(v-press-hold="[MouseMove, Click]")
    svg(viewBox="0 -112 1024 1024" :style="mirror.style")
      g.scale
        g.HairBack(:style="[$root.headRotate, $root.hair.side.basic]")
          Mane(name="hairTail" style="transform: scale(-1, 1) translate(-100%)"
            mask="url(#mask_Out_Head2)")

          Mane(name="hairTailSecond"
            :hide="!$root.mane.second.enable"
            :is-not-stroke="$root.mane.second.notLines"
            style="transform: scale(-1, 1) translate(-100%)"
            mask="url(#mask_In_Hair_Tail)")

        g.Head(:style="[$root.headRotate, $root.furTint]")
          g.moveEar(:style="$root.earsMove")
            Fur.inner2(name="earLeftInside"  :style="$root.furStroke")
            Fur.inner2(name="earRightInside" :style="$root.furStroke")

            Fur(name="earLeftPinna"  not-fill='yes' stroke-width=7)
            Fur(name="earRightPinna" not-fill='yes' stroke-width=7)

            Fur(name="earLeft"  not-fill='yes')
            Fur(name="earRight" not-fill='yes')

            Fur.inner4(name="earLeftTasselInside"  :style="$root.furStroke" not-fill='yes' alt='yes')
            Fur.inner4(name="earRightTasselInside" :style="$root.furStroke" not-fill='yes' alt='yes')

            Fur(name="earLeftTassel"  stroke-width=7)
            Fur(name="earRightTassel" stroke-width=7)

            g#earLeftPiercing

          g.HairBack3(style="transform: scale(-1, 1)"
            :style="$root.hair.side.alt" mask="url(#mask_no_RightEar_alt)")
            Mane(name="hairNape")
            Mane(name="hairNapeSecond" mask="url(#mask_In_Hair_Nape)"
              :hide="!$root.mane.second.enable"
              :is-not-stroke="$root.mane.second.notLines")

          Fur(name="head")

        g.Neck(:style="$root.furTint")
          Fur(name="chest")

          Fur.inner(name="neck" :style="$root.furStroke")

          Fur(name="neckBack_right" not-fill='yes')
          Fur(name="neckFront_left" not-fill='yes')

        g.HairBack2(:style="$root.headRotateHair" mask="url(#mask_Out_Head2)")
          Mane(name="hairTailFront" mask="url(#mask_no_RightEar_alt)")
          Mane(name="hairTailSecondFront"
            :hide="!$root.mane.second.enable"
            :is-not-stroke="$root.mane.second.notLines"
            mask="url(#mask_In_Hair_Tail)")

        g.Head(:style="[$root.headRotate, $root.furTint]")
          Fur.inner3(name="head2" alt='yes' :style="$root.furStroke")

        g.Hair2(:style="[$root.headRotate, $root.hair.side.basic]")
          Mane(name="hair" style="transform: scale(-1, 1) translate(-100%)")
          Mane(name="hairSecond" mask="url(#mask_In_Hair)"
            :hide="!$root.mane.second.enable"
            :is-not-stroke="$root.mane.second.notLines"
            style="transform: scale(-1, 1) translate(-100%)")

        g.Head(:style="[$root.headRotate, $root.furTint]")
          g.moveEar(:style="$root.earsMove")
            Fur.inner2(name="earRightInsideFront" alt='yes' :style="$root.furStroke")
            Fur(       name="earRightPinnaFront"        not-fill='yes' stroke-width=7)
            Fur(       name="earRightFront"             not-fill='yes')
            Fur.inner4(name="earRightTasselInsideFront" not-fill='yes' alt='yes' :style="$root.furStroke")
            Fur(       name="earRightTasselFront" stroke-width=7)

            g#earRightPiercing
              path.piercing(
                v-for="(obj, i) in $root.piercings.right"
                :key="'piercingRightEar' + i"

                :d="obj.type === 'ring' ? $root.piercings.ring : $root.piercings.point"
                :style="obj.style"
                :fill="obj.color"
                :stroke="obj.shade"
                stroke-width="6"
              )

          path#eyeLeftLashesUpper.outer.move(d fill-opacity="0" ref="eyeLeftLashesUpper"
            :style="[$root.faceMove, { stroke: '#222' }]")
          path#eyeLeftLashesMiddle.outer.move(d fill-opacity="0" ref="eyeLeftLashesMiddle"
            :style="[$root.faceMove, { stroke: '#222' }]")
          path#eyeLeftLashesLower.outer.move(d fill-opacity="0" ref="eyeLeftLashesLower"
            :style="[$root.faceMove, { stroke: '#222' }]")

          path#eyeLeft.eyes.move(d fill="#fff" mask="url(#mask_Head)" ref="eyeLeft" :style="$root.faceMove")

          path#eyeLeftBrow.outer.move(d fill-opacity="0" ref="eyeLeftBrow"
            :style="[$root.leftBrowWidth, $root.leftBrowHeight, { stroke: '#222' }]" mask="url(#mask_Head)")

          g.eyes.inside.Left(:style="$root.faceMove")
            ellipse#eyeIrisLeft(:fill="$root.eyeLeftGradient" ref="eyeIrisLeft")
            ellipse#eyePupilLeft(fill="#111" ref="eyePupilLeft")
            g
              ellipse#eyeGlareLeft( fill="#fff" ref="eyeGlareLeft")
              ellipse#eyeGlare2Left(fill="#fff" ref="eyeGlare2Left")

          Fur.inner4.move(name="eyeLeftLidDownFill" mask="url(#mask_Head)" :style="[$root.faceMove, $root.furStroke]")
          Fur.inner4.move(name="eyeLeftLidUpFill"   mask="url(#mask_Head)" :style="[$root.faceMove, $root.furStroke]")

          path#eyeLeftLidUp.outer.move(  d fill-opacity="0" mask="url(#mask_Head)"
            :style="[$root.faceMove, { stroke: '#222' }]" ref="eyeLeftLidUp")

          Fur(name="nose" stroke-width=7 :style="$root.furStroke")
          Fur(name="chinAngle" not-fill='yes')
          Fur(name="chin"      not-fill='yes' mask="url(#mask_Out_Head)")

          Fur.move(name="bridge" not-fill='yes' :style="$root.faceMove")

          g(mask="url(#mask_In_Head)" :style="$root.faceMove")
            path#mouth.move(d fill="#c47" stroke-width=7 ref="mouth")

            g(mask="url(#mask_In_Mouth)")
              path#tongue.mode(    d fill="#e83" stroke-width=5 stroke="#d72" ref="tongue")
              path#teethUpper.mode(d fill="#ffe" stroke-width=3 stroke="#ccb" ref="teethUpper")
              path#teethLower.mode(d fill="#ffe" stroke-width=3 stroke="#ccb" ref="teethLower")

            path#fangsLeft.move( d fill="#ffe" stroke-width=3 stroke="#ccb" ref="fangsLeft")
            path#fangsRight.move(d fill="#ffe" stroke-width=3 stroke="#ccb" ref="fangsRight")

            Fur.move(name="mouthOuter"  stroke-width=7 not-fill='yes')

          Fur.move(name="nostrilLeft" stroke-width=7 :style="$root.faceMove"
            mask="url(#mask_In_Nose)")

          Fur.move(name="nostrilRight" stroke-width=7 :style="$root.faceMove")

          g(mask="url(#mask_In_Head)" :style="$root.faceMove")
            path#mouthZone.Zone.move(d fill="#c47" ref="mouthZone")

          path#eyeRight.eyes.move(d fill="#fff" mask="url(#mask_Head)" :style="$root.faceMove" ref="eyeRight")

          g.eyes.inside.Right(:style="$root.faceMove")
            ellipse#eyeIrisRight(:fill="$root.eyeRightGradient" ref="eyeIrisRight")
            ellipse#eyePupilRight(fill="#111" ref="eyePupilRight")
            g
              ellipse#eyeGlareRight( fill="#fff" ref="eyeGlareRight")
              ellipse#eyeGlare2Right(fill="#fff" ref="eyeGlare2Right")

          Fur.inner4.move(name="eyeRightLidDownFill" mask="url(#mask_Head)"
            :style="[$root.faceMove, $root.furStroke]")
          Fur.inner4.move(name="eyeRightLidUpFill"   mask="url(#mask_Head)"
            :style="[$root.faceMove, $root.furStroke]")

          path#eyeRightLidUp.outer.move(  d fill-opacity="0" mask="url(#mask_Head)"
            :style="[$root.faceMove, { stroke: '#222' }]" ref="eyeRightLidUp")

          path#eyeRightLashesUpper.outer.move(d fill-opacity="0" ref="eyeRightLashesUpper"
            :style="[$root.faceMove, { stroke: '#222' }]")
          path#eyeRightLashesMiddle.outer.move(d fill-opacity="0" ref="eyeRightLashesMiddle"
            :style="[$root.faceMove, { stroke: '#222' }]")
          path#eyeRightLashesLower.outer.move(d fill-opacity="0" ref="eyeRightLashesLower"
            :style="[$root.faceMove, { stroke: '#222' }]")

          path#eyeRightBrow.outer.move(d fill-opacity="0" ref="eyeRightBrow"
            :style="[$root.rightBrowWidth, $root.rightBrowHeight, { stroke: '#222' }]")

        g.Hair(:style="$root.headRotate" mask="url(#mask_no_RightEar)")
          Mane(name="hairFront" :style="$root.hair.side.front")
          Mane(name="hairSecondFront" mask="url(#mask_In_Hair)"
            :hide="!$root.mane.second.enable"
            :is-not-stroke="$root.mane.second.notLines"
            :style="$root.hair.side.front")

          Mane(name="hairNapeFront" :style="$root.hair.side.front")
          Mane(name="hairNapeSecondFront" mask="url(#mask_In_Hair_Nape)"
            :hide="!$root.mane.second.enable"
            :is-not-stroke="$root.mane.second.notLines"
            :style="$root.hair.side.front")

        g.Head(:style="[$root.headRotate, $root.furTint]")
          Fur.move(name="horn" stroke-width=7 :hide="!$root.horn.enable")
          Fur.move(name="hornSecond" mask="url(#mask_In_Horn)"
            :hide="!$root.horn.enable"
            :not-fill="!$root.horn.notLines"
            :stroke-width="$root.horn.notLines ? 0 : 7"
            :second="true")

      defs
        mask#mask_Head(x="0" y="0" width="1024" height="1024")
          Clip(name="headClip" fill="#fff" stroke="#000" width="9.5" :style="$root.faceMoveReverse")

        mask#mask_Out_Head(x="0" y="0" width="1024" height="1024")
          rect(width="100%" height="100%" fill="#fff")
          Clip(name="headClip" fill="#000" stroke="#fff" width="9.5")

        mask#mask_Out_Head2(x="0" y="0" width="1024" height="1024")
          rect(width="100%" height="100%" fill="#fff")
          Clip(name="headClip"     fill="#000" stroke="#000" width="9.5")
          Clip(name="earRightClip" fill="#000" stroke="#000" width="9.5")

        mask#mask_In_Head(x="0" y="0" width="1024" height="1024")
          Clip(name="headClip" fill="#fff" stroke="#fff" width="9.5")
          Clip(name="noseClip" fill="#fff" stroke="#fff" width="9.5")

        mask#mask_In_Nose(x="0" y="0" width="1024" height="1024")
          Clip(name="noseClip" fill="#fff" stroke="#fff" width="14")

        mask#mask_no_RightEar(x="0" y="0" width="1024" height="1024")
          rect(width="100%" height="100%" fill="#fff")
          Clip(name="earRightClip" fill="#000" stroke="#000" :style="$root.earsClip")

        mask#mask_no_RightEar_alt(x="0" y="0" width="1024" height="1024")
          rect(width="100%" height="100%" fill="#fff")
          Clip(name="earRightClip" fill="#000" stroke="#000" :style="$root.earsClipAlt")

        mask#mask_Eyes(x="0" y="0" width="2024" height="2024")
          path#eyeLeftClip.eyes.Left(  :d="$root.path.eyeLeftClip"  fill="#fff")
          path#eyeRightClip.eyes.Right(:d="$root.path.eyeRightClip" fill="#fff")

          g(:style="$root.faceMoveReverse")
            Clip(name="headClip" fill="#0000" stroke="#000" width="10")
            circle(cx="512" cy="512" r="512" stroke="#000" stroke-width="517" fill="#0000")

        mask#mask_In_Mouth(x="0" y="0" width="1024" height="1024")
          Clip(name="mouthClip" fill="#fff" stroke="#000" width="6.5")

        mask#mask_In_Hair(x="0" y="0" width="1024" height="1024")
          Clip(name="hairClip" fill="#fff" stroke-width=8 stroke="#000")

        mask#mask_In_Hair_Nape(x="0" y="0" width="1024" height="1024")
          Clip(name="hairNapeClip" fill="#fff" stroke-width=8 stroke="#000")

        mask#mask_In_Hair_Tail(x="0" y="0" width="1024" height="1024")
          Clip(name="hairTailClip" fill="#fff" stroke-width=8 stroke="#000")
          Clip(name="headClip"     fill="#000" stroke="#000" width="9.5")
          Clip(name="earRightClip" fill="#000" stroke="#000" width="9.5")

        mask#mask_In_Horn(x="0" y="0" width="1024" height="1024")
          Clip(name="hornClip" fill="#fff" stroke="#000" width="6.5")

        linearGradient#grad_Eyes_Left(x1="0%" y1="100%" x2="0%" y2="0%")
          stop#1(offset="25%"  :style="{ 'stop-color': $root.eyes.color.left.basic, 'stop-opacity': 1 }")
          stop#2(offset="100%" :style="{ 'stop-color': $root.eyes.color.left.shade, 'stop-opacity': 1 }")

        linearGradient#grad_Eyes_Right(x1="0%" y1="100%" x2="0%" y2="0%")
          stop#1(offset="25%"  :style="{ 'stop-color': $root.eyes.color.right.basic, 'stop-opacity': 1 }")
          stop#2(offset="100%" :style="{ 'stop-color': $root.eyes.color.right.shade, 'stop-opacity': 1 }")
</template>

<script lang="coffee">
  import Clip from "./avatar/Clips.vue"
  import Fur  from "./avatar/Furs.vue"
  import Mane from "./avatar/Manes.vue"

  export default
    data: ->
      interpolate: require("polymorph-js").interpolate

      body: {}
      furs:
        male: {}

      furs2:
        male: {}

      hairs: {}
      emotions: {}

      degress: 10
      horiz: 0

      keys: new Array()

      x: 0.1111  # 10 degress (100% / 90deg)
      y: 0

      last:
        x: 0
        y: 0

      mirror:
        basic: no  # Avatar isnt mirrored in this time
        style:
          left: "50%"
          transform: "translate(-50%) scale(1, 1)"

    watch:
      "mirror.basic": (e) ->
        @mirror.style.transform =
          "translate(-50%) scale(#{ if e then -1 else 1 }, 1)"

      "$parent.editor.opened": (val) ->
        @mirror.style.left = if val then "33%" else "50%"

      degress: (num) ->
        if num < 0
             @mirror.basic = yes
        else @mirror.basic = no

      "$root.hair.name": (val) ->
        if @hairs[val] then @hair()
        else
          self = this
          hairName = @$root.hair.name.toLowerCase().replace /\W/g, "_"

          @get "hairs", "/data/pony/hairs/" + hairName + ".json", ->
            self.hair()

      "$root.hair.info": -> @hair()

      "$root.eyes":
        handler: -> @eyes()
        deep: yes

      "$root.eyes.brows":
        handler: -> @animate()
        deep: yes

      "$root.eyes.eyelids":
        handler: -> @animate()
        deep: yes

      "$root.eyes.color.right.enable": (val) ->
        if not val
          left = @$root.eyes.color.left

          @$root.eyes.color.right.basic  = left.basic
          @$root.eyes.color.right.shade  = left.shade
          @$root.eyes.color.right.stroke = left.stroke

      "$root.eyes.color.left":
        handler: (val) ->
          if not @$root.eyes.color.right.enable
            @$root.eyes.color.right.basic  = val.basic
            @$root.eyes.color.right.shade  = val.shade
            @$root.eyes.color.right.stroke = val.stroke

        deep: yes

      "$parent.male": -> @animate()

      "$root.mane.second.isEnds": -> @hair()

    computed:
      AbsoluteDegress: -> if @degress < 0 then -@degress else @degress

    methods:
      in: (array, range) ->
        #interpolation shorthand

        @interpolate(array) range

      get: (target, url, callback) ->
        self   = this
        loader = @$root.loadings
        capital = target[0].toUpperCase() + target.slice 1

        if target is "hairs"
          loader.push "#{capital} | #{@$root.hair.name}"
        else
          loader.push capital

        @$http.get(window.location.origin + url).then (res) ->
          self[target] = { self[target]..., res.body... }

          loader.splice loader.indexOf capital, 1

          setTimeout ->
            callback()
          , 100

        , (err) ->

          # Trying get again if not loaded

          setTimeout ->
            self.get(target, url, callback)
          , 5e3

      Click: (e) ->
        if not e.pageX
          if e.touches then e = e.touches[0] else return

        @last.x = e.pageX
        @last.y = e.pageY

      MouseMove: (e) ->
        if not e.pageX
          if e.touches then e = e.touches[0] else return

        BCR = @$el.getBoundingClientRect()

        ang = Math.atan2(
          ((@x + 1 / 2) * BCR.width)  - (BCR.left + BCR.width  / 2),
          ((@y + 1 / 2) * BCR.height) - (BCR.top  + BCR.height / 2)
        ) * 180 / Math.PI

        @x += (e.pageX - @last.x) / 500
        @y += (e.pageY - @last.y) / 100

        if @x > 1 then @x = 1 else if @x < -1 then @x = -1
        if @y > 1 then @y = 1 else if @y < -1 then @y = -1

        @degress = @x * 90

        horiz  = -(@y * (1 - Math.abs(@x))) ** 7
        @horiz = if horiz < 0 then horiz / 3 else horiz

        @$root.horiz   = @horiz
        @$root.ang     = (@y * 90 * Math.abs(@x)) / 4
        @$root.degress = @degress

        @animate()
        @eyes()
        @hair()

        @last.x = e.pageX
        @last.y = e.pageY

      ApplySvg: (text) ->
        pathTo = text.split /(?=[A-Z])/
        elem   = @$root.$refs

        if elem[text].tagName isnt "path" then return

        if pathTo[pathTo.length - 1] is "Front" or
           pathTo[pathTo.length - 1] is "Zone" then return

        furs = @furs
        keys = @keys
        furs2 = @furs2

        give = (inPath, i, isMale) ->
          if i is 0 and not furs2[pathTo[0]]
            furs2[pathTo[0]] = {}

          if i < pathTo.length
            name = pathTo[i].toLowerCase()

            give inPath[name], i + 1

          else
            if Array.isArray inPath
              furs[text] = inPath

              if text is pathTo[0]
                furs2[text] = inPath
              else
                name = text.replace pathTo[0], ""

                furs2[pathTo[0]][name] = inPath

              keys[keys.length] = text

              if isMale
                furs.male[text] = inPath
                furs2.male[text] = inPath

              if text is "mouth"
                furs.mouthOuter = furs.mouth
                furs2.mouthOuter = furs2.mouth

            else
              if inPath.male
                give inPath.male["basic"], i, yes

              give inPath["basic"], i

        give @body, 0

      calc: (name, callback) ->
        if Array.isArray name
          name2 = name[1]
          name  = name[0]

        if @$parent.male and @furs2.male[name]
          if name2
               part = @furs2.male[name][name2]
          else part = @furs2.male[name]
        else
          if name2 and @furs2[name]
               part = @furs2[name][name2]
          else part = @furs2[name]

        self = this
        root = @$root

        set = (name, second) ->
          if second
            if self.$parent.male and self.furs2.male[name] and self.furs2.male[name][second]
              if name2
                   part = self.furs2.male[name][name2][second]
              else part = self.furs2.male[name][second]
            else
              if name2
                   part = self.furs2[name][name2][second]
              else part = self.furs2[name][second]

          length = part.length - 1
          fullRange = self.x * length

          absPercent = self.AbsoluteDegress / 90

          if name is "chin"
            if self.degress > 0
              if self.degress > 30
                   fullRange = absPercent ** 0.75 * length
              else fullRange = absPercent ** 2.5  * length * 6.8
            else
              if self.degress > -30
                   fullRange = absPercent ** 2.5  * length * 6.8
              else fullRange = absPercent ** 0.75 * length

          else if name in ["nose", "bridge", "mouth", "fangs", "nostril", "teeth"]
            if self.degress > 0
              if self.degress > 30
                   fullRange = absPercent ** 0.5 * length
              else fullRange = absPercent ** 2   * length * 5.15
            else
              if self.degress > -30
                   fullRange = absPercent ** 2   * length * 5.15
              else fullRange = absPercent ** 0.5 * length

          else if name in ["eyeLeftLashesUpper", "eyeLeftLashesMiddle",
            "eyeLeftLashesLower" ]

            if self.degress > 0
              if self.degress > 30
                   fullRange = absPercent ** 0.25 * length
              else fullRange = absPercent ** 0.75 * length * 1.75
            else
              if self.degress > -30
                   fullRange = absPercent ** 0.75 * length * 1.75
              else fullRange = absPercent ** 0.25 * length


          frame = Math.floor fullRange
          range = fullRange - frame

          if frame < 0
            frame = part.length - 1 + frame
            range = 1 - range

          else frame = part.length - 2 - frame

          if frame < 0 then frame = 0; range = 1
          if not second then second = ""
          if not  name2 then  name2 = ""

          if callback then path = callback frame, part, name + name2 + second, fullRange

          if path and path.range isnt undefined then range = path.range

          pathData =
            if path and path.path then path.path range else
              if path and path.origin
                   self.interpolate([part[frame + 1], part[frame]], origin: path.origin) range
              else self.interpolate([part[frame + 1], part[frame]]) range

          elem = root.$refs[name + name2 + second]

          if root.$refs[name + name2 + second + "Front"]
            elemFront = root.$refs[name + name2 + second + "Front"]

          if path and path.front
            elemFront.setAttribute "d", pathData
            elem.setAttribute "d", ""

          else if path and path.clear
            elem.setAttribute "d", ""
            if elemFront then elemFront.setAttribute "d", ""

          else
            elem.setAttribute "d", pathData
            if elemFront then elemFront.setAttribute "d", ""

          if path and path.clip
            root.path[name + name2 + second + "Clip"] = pathData

        if Array.isArray part then setTimeout (-> set name)
        else
          if not part then return

          keys = Object.keys part
          i    = 0

          cycle = (i) -> setTimeout (->
            set name, keys[i]; i++
            set name, keys[i]; i++

            if not i >= keys.length
              set name, keys[i]; i++

            if i < keys.length then cycle i
          )

          cycle i

      animate: ->
        clips = @$root.path
        refs  = @$root.$refs
        self  = this
        eyelids  = @$root.eyes.eyelids
        emotions = @emotions.eyelid

        eyelid = [
          { val: eyelids.left.up,    target: emotions.left.down      }
          { val: eyelids.left.up,    target: emotions.left.up.fill   }
          { val: eyelids.left.down,  target: emotions.left.up.basic  }
          { val: eyelids.left.down,  target: refs["eyeLeft"].getAttribute "d" }
          { val: eyelids.right.up,   target: emotions.right.down     }
          { val: eyelids.right.up,   target: emotions.right.up.fill  }
          { val: eyelids.right.down, target: emotions.right.up.basic }
          { val: eyelids.right.down, target: refs["eyeRight"].getAttribute "d" }
        ]

        isEyelid  =
          [ "eyeLeftLidUp",  "eyeLeftLidUpFill",  "eyeLeftLidDown",  "eyeLeftLidDownFill",
            "eyeRightLidUp", "eyeRightLidUpFill", "eyeRightLidDown", "eyeRightLidDownFill" ]

        lashes =
          [ "eyeLeftLashesUpper",  "eyeLeftLashesMiddle",  "eyeLeftLashesLower",
            "eyeRightLashesUpper", "eyeRightLashesMiddle", "eyeRightLashesLower" ]

        @calc "bridge"
        @calc "chest"
        @calc "chin"
        @calc "neck"
        @calc ["neck", "Back_right"]
        @calc ["neck", "Front_left"]
        @calc "nostril"

        @calc "head2"
        @calc "nose", () -> clip: yes
        @calc "head", () -> clip: yes
        @calc "horn", () -> clip: yes
        @calc ["horn", "Second"], () ->
          origin: x: 0.75, y: 0.75

        @calc "tongue", (frame, paths, key) ->
          refs[key].setAttribute "style",
            "transform: translate(0%, #{ -(2 - self.$root.jaw.open / 50) }%)"

        @calc "teeth", (frame, paths, key) ->
          if key is "teethUpper"
            refs[key].setAttribute "style",
              "transform: translate(0%, #{ -(4 - self.$root.teeth.upper / 25) }%)"

          else if key is "teethLower"
            refs[key].setAttribute "style",
              "transform: translate(0%, #{ 4 - self.$root.teeth.lower / 25 }%)"

        @calc "fangs", (frame, paths) ->
          path: if self.$root.fangs then self.interpolate [paths[frame + 1], paths[frame]]
          clear: if not self.$root.fangs then true

        @calc "ear", (frame, paths, key) ->
          # Set ear to "front or not"

          if /Right/.test key
            clear = no
            front = no

            if self.$root.horiz <= 0 or self.AbsoluteDegress >= 45
              if key in ["earRightTassel", "earRightTasselInside"] and not self.$root.tassels
                   clear = yes
              else front = yes

            else
              if key in ["earRightTassel", "earRightTasselInside"] and not self.$root.tassels
                clear = yes

          path: self.interpolate [paths[frame + 1], paths[frame]]
          clip: if key in ["earLeft", "earRight"] then true
          front: front
          clear: clear

        anim = @in

        @calc "mouth", (frame, paths, key, range) ->
          if self.$root.catlike
            horiz = [
              self.emotions.catlike.jaw[frame + 1],
              self.emotions.catlike.jaw[frame]
            ]

          else horiz = [paths[frame + 1], paths[frame]]

          jaw   = self.$root.jaw
          type  = if self.$root.catlike then "catlike" else "basic"
          range = range - (3 - frame)

          sad  = self.emotions.sad.jaw
          open = self.emotions.open.jaw

          animSumm =
            anim [
              anim(horiz, range),
              anim [sad[type].closed[frame + 1], sad[type].closed[frame]], range
            ], jaw.sad / 100

          morph =
            self.interpolate [
              animSumm,
              anim [
                anim([    open[type][frame + 1],     open[type][frame]], range),
                anim [sad[type].open[frame + 1], sad[type].open[frame]], range
              ], jaw.sad / 100
            ]

          refs["mouthOuter"].setAttribute "d", animSumm

          path: morph
          range: jaw.open / 100
          clip: true

        @calc "eye", (frame, paths, key, range) ->
          if range < 0 then range = -range

          if key in isEyelid
            id     = isEyelid.indexOf key
            range  = range - (1 - frame)
            target = eyelid[id].target

            if self.degress < 0
              if id >= 4 then id -= 4 else id += 4

            val = eyelid[id].val

            if eyelid[id].val > 0 or key in ["eyeLeftLidUp", "eyeRightLidUp"]
              if typeof target isnt "string"
                target = anim [target[frame + 1], target[frame]], range

              morph = self.interpolate [
                anim([paths[frame + 1], paths[frame]], range),
                target
              ]

            else clear = yes

          else if key in lashes
            if range >= 1.9 or self.$parent.male
              clear = yes

            side   = key.match(/Left|Right/)[0].toLowerCase()
            range  = range - (1 - frame)
            closed = self.body.eye[side].lashes

            if self.degress < 0
              side = if side is "left" then "right" else "left"

            parts =
              [ "upper", "middle", "lower",
                "upper", "middle", "lower" ]

            path2 = closed[parts[lashes.indexOf key]].closed
            morph =
              self.interpolate [
                anim([paths[frame + 1], paths[frame]], range),
                anim [path2[frame + 1], path2[frame]], range
              ]

            val = self.$root.eyes.eyelids[side].up

          else if key in ["eyeLeftBrow", "eyeRightBrow"]
            brow  = self.$root.eyes.brows
            range = range - (1 - frame)

            if brow.show
              side    = if key  is "eyeLeftBrow" then "left" else "right"
              sideAlt = if side is "left"        then "right" else "left"

              eye  = self.body.eye
              evil = eye[side].brow.evil
              wide = eye[side].brow.wide

              val =
                evil: if self.degress >= 0 then brow[sideAlt].evil else brow[side].evil
                wide: if self.degress >= 0 then brow[sideAlt].wide else brow[side].wide

              morph =
                self.interpolate [
                  anim([
                    anim([paths[frame + 1], paths[frame]], range),
                    anim [evil[frame + 1], evil[frame]], range
                  ], val.evil / 100),

                  anim [wide[frame + 1], wide[frame]], range
                ]

            else clear = true

          path:  if morph then morph
          range:
            if morph and /Brow/.test key then val.wide / 100
            else if morph then val / 100

          clip:  if key in ["eyeLeft", "eyeRight"] then true
          clear: clear

      eyes: ->
        refs = @$root.$refs

        bbox =
          left:  refs.eyeLeft.getBBox()
          right: refs.eyeRight.getBBox()

        if bbox.left.x is 0 or bbox.left.x is 0
          self = this
          setTimeout (-> self.eyes()), 100
          return

        scale = @$root.eyes.iris.scale / 100
        posit = @$root.eyes.position

        shift =
          y: posit.verti - 50  # What?
          x: posit.horiz - 50

        derp = posit.derp

        if @degress < 0 then shift.x = -shift.x; derp = -derp

        absolute = x: 0, y: 0

        if @$root.eyes.position.mode is "absolute"
          absolute =
            x: -@AbsoluteDegress / 1.5
            y: if @horiz < 0 then @horiz * 30 * 2 else @horiz * 30

        middle =
          left:
            x: bbox.left.x + bbox.left.width  / 2 - 10 + shift.x - (25 - posit.focus / 4)
            y: bbox.left.y + bbox.left.height / 2 + 16 - shift.y + (derp / 1.5)

          right:
            x: bbox.right.x + bbox.right.width  / 2 + 10 + shift.x + (25 - posit.focus / 4)
            y: bbox.right.y + bbox.right.height / 2 + 16 - shift.y - (derp / 1.5)

        set = (obj) ->
          obj.elem.setAttribute "cx", obj.cx
          obj.elem.setAttribute "cy", obj.cy
          obj.elem.setAttribute "rx", obj.rx
          obj.elem.setAttribute "ry", obj.ry


        # Iris

        set
          elem: refs.eyeIrisLeft

          cx: middle.left.x + absolute.x
          cy: middle.left.y + absolute.y

          rx: 7.5  * scale + "%"
          ry: 13.5 * scale + "%"

        set
          elem: refs.eyeIrisRight

          cx: middle.right.x + (@AbsoluteDegress / 3) + absolute.x
          cy: middle.right.y + absolute.y

          rx: 7.5  * scale + "%"
          ry: 13.5 * scale + "%"


        # Pupils

        set
          elem: refs.eyePupilLeft

          cx: middle.left.x - 10 + absolute.x
          cy: middle.left.y + absolute.y

          rx: 6  * @$root.eyes.pupils.width  * scale / 100 + "%"
          ry: 10 * @$root.eyes.pupils.height * scale / 100 + "%"

        set
          elem: refs.eyePupilRight

          cx: middle.right.x + 10 + (@AbsoluteDegress / 3) + absolute.x
          cy: middle.right.y + absolute.y

          rx: 6  * @$root.eyes.pupils.width  * scale / 100 + "%"
          ry: 10 * @$root.eyes.pupils.height * scale / 100 + "%"


        # Glares

        ang = if @degress < 0 then 45 else -45
        pos = if @degress < 0 then 15 else -15

        set
          elem: refs.eyeGlareLeft

          cx: middle.left.x - (pos - (@AbsoluteDegress / 3) * scale) + absolute.x
          cy: middle.left.y - (85 * scale) + absolute.y

          rx: 3   * scale + "%"
          ry: 5.5 * scale + "%"

        refs.eyeGlareLeft.setAttribute "style",
          "transform: rotate(#{ ang }deg); transform-origin: " +
            "#{ middle.left.x - (pos - (@AbsoluteDegress / 3) * scale) + absolute.x }px " +
            "#{ middle.left.y - (85 * scale) + absolute.y }px"

        set
          elem: refs.eyeGlare2Left

          cx: middle.left.x + (pos * 2) + (@AbsoluteDegress / 3) + absolute.x
          cy: middle.left.y - (60 * scale) + absolute.y

          rx: 1.25 * scale + "%"
          ry: 2    * scale + "%"

        refs.eyeGlare2Left.setAttribute "style",
          "transform: rotate(#{ ang }deg); transform-origin: " +
            "#{ middle.left.x + (pos * 2) + (@AbsoluteDegress / 3) + absolute.x }px " +
            "#{ middle.left.y - (60 * scale) + absolute.y }px"


        set
          elem: refs.eyeGlareRight

          cx: middle.right.x - (pos - (@AbsoluteDegress / 3) * scale) + absolute.x
          cy: middle.right.y - (85 * scale) + absolute.y

          rx: 3   * scale + "%"
          ry: 5.5 * scale + "%"

        refs.eyeGlareRight.setAttribute "style",
          "transform: rotate(#{ ang }deg); transform-origin: " +
            "#{ middle.right.x - (pos - (@AbsoluteDegress / 3) * scale) + absolute.x }px " +
            "#{ middle.right.y - (85 * scale) + absolute.y }px"

        set
          elem: refs.eyeGlare2Right

          cx: middle.right.x + (pos * 2) + (@AbsoluteDegress / 3) + absolute.x
          cy: middle.right.y - (60 * scale) + absolute.y

          rx: 1.25 * scale + "%"
          ry: 2    * scale + "%"

        refs.eyeGlare2Right.setAttribute "style",
          "transform: rotate(#{ ang }deg); transform-origin: " +
            "#{ middle.right.x + (pos * 2) + (@AbsoluteDegress / 3) + absolute.x }px " +
            "#{ middle.right.y - (60 * scale) + absolute.y }px"

      hair: ->
        hair = @$root.hair

        if !hair.info[hair.id] then return

        refs      = @$root.$refs
        hairPaths = @hairs[hair.name]

        elems = [
          "hair", "hairSecond",
          "hairNape", "hairNapeSecond",
          "hairTail", "hairTailSecond"
        ]

        parts = ["front", "back", "tail"]

        i2 = -1

        for elem, i in elems
          if i % 2 is 0 then i2++

          isSecond = if i % 2 is 0 then "main" else
            if @$root.mane.second.isEnds and hairPaths[parts[i2]].ends
              "ends"
            else "second"

          paths     = hairPaths[parts[i2]][isSecond]
          fullRange = @x * 2

          frame = Math.floor fullRange
          range = fullRange - frame
          mirroring = hair.info[hair.id].mirroring

          if hairPaths.fix and hairPaths.fix[parts[i2]] and
             hairPaths.fix[parts[i2]][isSecond] and
             hairPaths.fix[parts[i2]][isSecond].x

            origin = origin: hairPaths.fix[parts[i2]][isSecond]

          else origin = origin: x: 0, y: 0

          setBehind = ->
            refs[elem].setAttribute "d", animHoriz range
            refs[elem + "Front"].setAttribute "d", ""

          setFront = ->
            refs[elem + "Front"].setAttribute "d", animHoriz range
            refs[elem].setAttribute "d", ""

          setClear = ->
            refs[elem].setAttribute "d", ""
            refs[elem + "Front"].setAttribute "d", ""

          frame = 2 + frame

          if frame > 3 then frame = 3; range = 1

          if paths.length is 0 then setClear(); continue

          animHoriz =
            if frame > 1 and mirroring
              @interpolate [paths[4 - frame], paths[3 - frame]], origin
            else
              @interpolate [paths[frame], paths[frame + 1]], origin

          if isSecond
            @$root.path[elem + "Clip"] = animHoriz range

          if elem in ["hair", "hairSecond"] then setFront()
          else if elem in ["hairTail", "hairTailSecond"] and hair isnt "Curly ends"
            setFront()
          else if elem in ["hairTail", "hairTailSecond"] and hair isnt "Curly ends" and @degress > 0
            setFront()

          else if hair.name in ["Curly ends"]
            if elem in ["hairTail", "hairTailSecond"] and @degress > 0 then setFront() else
            if elem in ["hairNape", "hairNapeSecond"] and @degress < 0 then setFront()
            else setBehind()

          else setBehind()

        side = hair.side

        if @degress < 0 and not mirroring
          side.basic = transform: "scale(-1, 1)"
          side.alt   = transform: ""
          side.front = transform: ""

        else
          side.basic = transform: ""
          side.alt   = transform: "scale(-1, 1)"
          side.front = transform: "scale(-1, 1) translate(-100%)"

    mounted: ->
      @$root.$refs = { @$root.$refs..., @$refs...}

      self = this


      # Get JSON data to client and execute

      @get "body", "/data/pony/body.json", ->

        # SVG parsing - import

        for key of self.$root.$refs
          if key not in [
            "mouthOuter",
            "hair", "hairFront",
            "hairSecond", "hairSecondFront",
            "hairNape", "hairNapeFront",
            "hairNapeSecond", "hairNapeSecondFront",
            "hairTail", "hairTailFront",
            "hairTailSecond", "hairTailSecondFront"
          ]

            self.ApplySvg(key)

        self.animate()
        self.eyes()


      # Load first hair

      hairName = @$root.hair.name.toLowerCase().replace /\W/g, "_"

      @get "hairs", "/data/pony/hairs/" + hairName + ".json", -> self.hair()

      @get "emotions", "/data/pony/emotions.json", ->
        self.animate()
        self.eyes()


      # Set multi watcher

      @$watch (->
        [ @$root.tassels, @$root.fangs, @$root.catlike,

          @$root.jaw.open, @$root.jaw.sad,
          @$root.teeth.upper, @$root.teeth.lower,

          @$root.earClipEnabled
        ].join()

      ), -> @animate(); return

    components: {
      Clip
      Fur
      Mane
    }
</script>

<style lang="sass">
  #nose, .eyes
    stroke-opacity: 0

  .Zone
    fill: transparent
    stroke: #af68
    stroke-width: 40

  #eye_Left, #eye_Right 
    mask: url("#mask_Head")

  #eyeGlare2_Left, #eyeGlare2_Right, #eyeGlare_Left, #eyeGlare_Right
    -moz-transform: rotate(30deg)
    transform: rotate(30deg)

  .inside
    transform-origin: center
    mask: url("#mask_Eyes")

  .eyes.mask
    mask: url("#mask_Head")

  .inner
    stroke: #ccc
    stroke-width: 9
    stroke-linejoin: bevel

  .inner2
    stroke: #ccc
    stroke-width: 10.5
    stroke-linejoin: bevel

  .inner3
    stroke: #ccc
    stroke-width: 20
    stroke-linejoin: bevel

  .inner4
    stroke: #ccc
    stroke-width: 7
    stroke-linejoin: bevel

  .outer
    stroke: #888
    stroke-width: 7
    stroke-linejoin: bevel
</style>
